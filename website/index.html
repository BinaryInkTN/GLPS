<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLPS | Modern Cross-Platform Library</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.min.css">
    <style>
        :root {
            --primary: #4285f4;
            --primary-light: #8ab4f8;
            --primary-dark: #1a73e8;
            --secondary: #34a853;
            --accent: #ea4335;
            --surface: #ffffff;
            --background: #f8f9fa;
            --on-surface: #202124;
            --on-background: #5f6368;
            --border: #dadce0;
            --shadow: 0 1px 2px 0 rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);
            --shadow-hover: 0 1px 3px 0 rgba(60,64,67,0.3), 0 4px 8px 3px rgba(60,64,67,0.15);
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            font-family: 'Google Sans', 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--background);
            color: var(--on-surface);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        /* Header */
        #globalheader {
            background: var(--surface);
            color: var(--on-surface);
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            height: 72px;
            display: flex;
            align-items: center;
            padding: 0 5%;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }
        
        #globalheader.scrolled {
            height: 64px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
        }
        
        .logo {
            font-weight: 500;
            font-size: 22px;
            color: var(--primary);
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo-icon {
            width: 32px;
            height: 32px;
            background: var(--primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
        }
        
        #globalnav ul {
            list-style: none;
            display: flex;
            gap: 32px;
        }
        
        #globalnav a {
            color: var(--on-background);
            text-decoration: none;
            font-weight: 500;
            font-size: 14px;
            transition: var(--transition);
            position: relative;
            padding: 8px 0;
        }
        
        #globalnav a:hover { 
            color: var(--primary); 
        }
        
        #globalnav a.active {
            color: var(--primary);
        }
        
        #globalnav a.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--primary);
        }
        
        .mobile-toggle {
            display: none;
            background: none;
            border: none;
            color: var(--on-surface);
            font-size: 20px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: var(--transition);
        }
        
        .mobile-toggle:hover {
            background: var(--background);
        }
        
        /* Hero */
        .hero {
            margin-top: 72px;
            padding: 120px 5% 100px;
            background: linear-gradient(135deg, var(--surface) 0%, var(--background) 100%);
            position: relative;
            overflow: hidden;
        }
        
        .hero::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -20%;
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, var(--primary-light) 0%, transparent 70%);
            opacity: 0.1;
            border-radius: 50%;
        }
        
        .hero-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 80px;
            align-items: center;
            position: relative;
            z-index: 1;
        }
        
        .hero-text {
            position: relative;
        }
        
        .hero h1 { 
            font-size: 48px;
            font-weight: 400;
            margin-bottom: 24px;
            line-height: 1.1;
            color: var(--on-surface);
        }
        
        .hero h1 strong {
            font-weight: 500;
            color: var(--primary);
        }
        
        .hero p { 
            font-size: 20px;
            color: var(--on-background);
            margin-bottom: 40px;
            line-height: 1.6;
        }
        
        .hero-badges {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 40px;
        }
        
        .badge {
            background: var(--surface);
            color: var(--on-background);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 6px;
            transition: var(--transition);
        }
        
        .badge:hover {
            border-color: var(--primary-light);
            box-shadow: var(--shadow);
        }
        
        .hero-buttons {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        
        .hero-screenshot {
            background: var(--surface);
            border-radius: 16px;
            padding: 24px;
            box-shadow: var(--shadow-hover);
            border: 1px solid var(--border);
            transition: var(--transition);
        }
        
        .hero-screenshot:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .screenshot-placeholder {
            width: 100%;
            height: auto;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }
        
        .screenshot-placeholder::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .button {
            padding: 16px 32px;
            border-radius: 8px;
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
        }
        
        .button.primary { 
            background: var(--primary); 
            color: white; 
            box-shadow: var(--shadow);
        }
        
        .button.primary:hover { 
            background: var(--primary-dark); 
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }
        
        .button.secondary { 
            background: var(--surface); 
            border: 1px solid var(--border);
            color: var(--on-surface); 
        }
        
        .button.secondary:hover { 
            background: var(--background);
            border-color: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }
        
        /* Section */
        .section {
            max-width: 1200px;
            margin: 0 auto;
            padding: 100px 5%;
        }
        
        .section-header {
            text-align: center;
            margin-bottom: 80px;
        }
        
        .section-header h2 { 
            font-size: 42px;
            font-weight: 400;
            margin-bottom: 16px;
            color: var(--on-surface);
        }
        
        .section-header p {
            font-size: 20px;
            color: var(--on-background);
            max-width: 600px;
            margin: 0 auto;
        }
        
        /* Grid */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 32px;
        }
        
        .card {
            background: var(--surface);
            border-radius: 16px;
            padding: 32px;
            box-shadow: var(--shadow);
            transition: var(--transition);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--primary);
            transform: scaleX(0);
            transition: var(--transition);
        }
        
        .card:hover { 
            transform: translateY(-8px);
            box-shadow: var(--shadow-hover);
        }
        
        .card:hover::before {
            transform: scaleX(1);
        }
        
        .card-icon {
            width: 64px;
            height: 64px;
            background: var(--background);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 24px;
            color: var(--primary);
            font-size: 24px;
            transition: var(--transition);
        }
        
        .card:hover .card-icon {
            background: var(--primary);
            color: white;
        }
        
        .card h3 { 
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--on-surface);
        }
        
        .card p { 
            color: var(--on-background);
            font-size: 16px;
            line-height: 1.6;
        }
        
        /* Comparison Table */
        .comparison {
            background: var(--surface);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }
        
        .comparison table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .comparison th, .comparison td {
            padding: 24px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        .comparison th {
            background: var(--background);
            color: var(--on-surface);
            font-weight: 500;
            font-size: 16px;
        }
        
        .comparison tr:last-child td {
            border-bottom: none;
        }
        
        .comparison .feature {
            font-weight: 500;
            color: var(--on-surface);
        }
        
        .check {
            color: var(--secondary);
            font-weight: 500;
        }
        
        .check::before {
            content: '✓';
            margin-right: 8px;
        }
        
        .cross {
            color: var(--accent);
            font-weight: 500;
        }
        
        .cross::before {
            content: '✗';
            margin-right: 8px;
        }
        
        /* Code Example */
        .code-example {
            background: var(--surface);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: var(--shadow);
            margin-bottom: 32px;
            border: 1px solid var(--border);
        }
        
        .code-header {
            background: var(--background);
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }
        
        .code-header h3 {
            color: var(--on-surface);
            font-size: 18px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .code-actions {
            display: flex;
            gap: 8px;
        }
        
        .code-btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--on-background);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .code-btn:hover {
            background: var(--background);
            border-color: var(--primary-light);
            color: var(--primary);
        }
        
        .code-content {
            position: relative;
        }
        
        .CodeMirror {
            height: auto;
            font-family: 'Fira Code', 'Cascadia Code', monospace;
            font-size: 14px;
            line-height: 1.5;
            border-radius: 0 0 16px 16px;
        }
        
        .CodeMirror-scroll {
            min-height: 300px;
            max-height: 500px;
        }
        
        /* Footer */
        .footer {
            background: var(--surface);
            color: var(--on-background);
            padding: 80px 5% 40px;
            border-top: 1px solid var(--border);
        }
        
        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 48px;
            margin-bottom: 48px;
        }
        
        .footer-about {
            max-width: 400px;
        }
        
        .footer-logo {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .footer p {
            margin-bottom: 24px;
            line-height: 1.6;
            color: var(--on-background);
        }
        
        .footer h4 {
            color: var(--on-surface);
            margin-bottom: 20px;
            font-size: 16px;
            font-weight: 500;
        }
        
        .footer-links {
            list-style: none;
        }
        
        .footer-links li {
            margin-bottom: 12px;
        }
        
        .footer-links a {
            color: var(--on-background);
            text-decoration: none;
            transition: var(--transition);
            font-size: 14px;
        }
        
        .footer-links a:hover {
            color: var(--primary);
        }
        
        .footer-bottom {
            max-width: 1200px;
            margin: 0 auto;
            padding-top: 32px;
                        padding-bottom: 32px;

            border-top: 1px solid var(--border);
            text-align: center;
            font-size: 14px;
            color: var(--on-background);
        }
        
        .social-links {
            display: flex;
            gap: 16px;
            margin-top: 20px;
        }
        
        .social-links a {
            color: var(--on-background);
            font-size: 18px;
            transition: var(--transition);
            padding: 8px;
            border-radius: 50%;
        }
        
        .social-links a:hover {
            color: var(--primary);
            background: var(--background);
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .footer-content {
                grid-template-columns: 1fr 1fr;
                gap: 40px;
            }
        }
        
        @media (max-width: 768px) {
            #globalnav {
                position: fixed;
                top: 72px;
                left: 0;
                width: 100%;
                background: var(--surface);
                padding: 24px;
                transform: translateY(-100%);
                opacity: 0;
                visibility: hidden;
                transition: var(--transition);
                box-shadow: var(--shadow);
            }
            
            #globalnav.active {
                transform: translateY(0);
                opacity: 1;
                visibility: visible;
            }
            
            #globalnav ul {
                flex-direction: column;
                gap: 16px;
            }
            
            .mobile-toggle {
                display: block;
            }
            
            .hero-content {
                grid-template-columns: 1fr;
                gap: 48px;
                text-align: center;
            }
            
            .hero h1 {
                font-size: 36px;
            }
            
            .hero p {
                font-size: 18px;
            }
            
            .hero-buttons {
                justify-content: center;
            }
            
            .button {
                width: 100%;
                max-width: 280px;
                justify-content: center;
            }
            
            .section {
                padding: 80px 5%;
            }
            
            .section-header h2 {
                font-size: 32px;
            }
            
            .comparison {
                overflow-x: auto;
            }
            
            .comparison table {
                min-width: 600px;
            }
            
            .footer-content {
                grid-template-columns: 1fr;
                gap: 32px;
            }
        }
    </style>
</head>
<body>

<!-- Header -->
<div id="globalheader">
    <div class="logo">
      
        GLPS
    </div>
    <nav id="globalnav">
        <ul>
            <li><a href="#features" class="active">Features</a></li>
            <li><a href="#comparison">Comparison</a></li>
            <li><a href="#examples">Examples</a></li>
            <li><a href="docs/index.html">Documentation</a></li>
        </ul>
    </nav>
    <button class="mobile-toggle" id="mobileToggle">
        <i class="fas fa-bars"></i>
    </button>
</div>

<!-- Hero -->
<div class="hero">
    <div class="hero-content">
        <div class="hero-text">
            <h1>Leaner, Meaner, <strong>Cleaner.</strong>  </h1>
            <p>GLPS provides a lightweight, cross-platform solution for window management, input handling, and audio without the complexity of traditional frameworks.</p>
            
            <div class="hero-badges">
                <div class="badge">
                    <i class="fas fa-bolt"></i>
                    High Performance
                </div>
                <div class="badge">
                    <i class="fas fa-shield-alt"></i>
                    Zero Dependencies
                </div>
                <div class="badge">
                    <i class="fas fa-code"></i>
                    Pure C API
                </div>
            </div>
            
            <div class="hero-buttons">
                <a href="https://github.com/BinaryInkTN/GLPS" class="button primary">
                    <i class="fas fa-download"></i> Get Started
                </a>
                <a href="docs/index.html" class="button secondary">
                    <i class="fas fa-book"></i> View Documentation
                </a>
            </div>
        </div>
        <div class="hero-screenshot">
            <div class="screenshot-placeholder">
                           <img src="screenshot.jpg" width="500"/>

            </div>
        </div>
    </div>
</div>

<!-- Features -->
<div class="section" id="features">
    <div class="section-header">
        <h2>Built for modern development</h2>
        <p>GLPS combines performance with simplicity, offering everything you need without unnecessary complexity</p>
    </div>
    <div class="grid">
        <div class="card">
            <div class="card-icon">
                <i class="fas fa-rocket"></i>
            </div>
            <h3>Lightweight & Fast</h3>
            <p>Minimal footprint with no external dependencies. Perfect for embedded systems and performance-critical applications where every kilobyte matters.</p>
        </div>
        <div class="card">
            <div class="card-icon">
                <i class="fas fa-layer-group"></i>
            </div>
            <h3>Cross-Platform</h3>
            <p>Native support for Windows and Linux (X11 and Wayland) with a consistent, predictable API across all platforms and architectures.</p>
        </div>
        <div class="card">
            <div class="card-icon">
                <i class="fas fa-volume-up"></i>
            </div>
            <h3>Audio Ready</h3>
            <p>Built-in audio playback and capture with support for ALSA out of the box.</p>
        </div>
        <div class="card">
            <div class="card-icon">
                <i class="fas fa-puzzle-piece"></i>
            </div>
            <h3>Graphics Integration</h3>
            <p>Seamless integration with Vulkan, OpenGL, and DirectX. Create rendering contexts with minimal boilerplate code.</p>
        </div>
        <div class="card">
            <div class="card-icon">
                <i class="fas fa-gamepad"></i>
            </div>
            <h3>Input Management</h3>
            <p>Comprehensive support for keyboard, mouse, gamepad, and touch input with intelligent cross-platform normalization and event handling.</p>
        </div>
        <div class="card">
            <div class="card-icon">
                <i class="fas fa-code-branch"></i>
            </div>
            <h3>Simple API</h3>
            <p>Clean, intuitive C API designed for ease of use and extensibility. No complex abstractions or hidden performance costs.</p>
        </div>
    </div>
</div>

<!-- Comparison -->
<div class="section" id="comparison">
    <div class="section-header">
        <h2>Why choose GLPS?</h2>
        <p>See how GLPS compares to other popular windowing libraries</p>
    </div>
    <div class="comparison">
        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>GLPS</th>
                    <th>GLFW</th>
                    <th>SDL2</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="feature">Binary Size</td>
                    <td class="check">200KB</td>
                    <td class="cross">~400KB</td>
                    <td class="cross">~10MB</td>
                </tr>
                <tr>
                    <td class="feature">Dependencies</td>
                    <td class="check">None</td>
                    <td class="check">None</td>
                    <td class="cross">System libraries</td>
                </tr>
                <tr>
                    <td class="feature">Wayland Support</td>
                    <td class="check">Native</td>
                    <td class="check">Extension</td>
                    <td class="cross">Limited</td>
                </tr>
                <tr>
                    <td class="feature">Audio Support</td>
                    <td class="check">Built-in</td>
                    <td class="cross">No</td>
                    <td class="check">Yes</td>
                </tr>
                <tr>
                    <td class="feature">Vulkan Integration</td>
                    <td class="check">Direct</td>
                    <td class="check">Extension</td>
                    <td class="check">Extension</td>
                </tr>
                <tr>
                    <td class="feature">Language Support</td>
                    <td class="check">C Focused</td>
                    <td class="check">C/C++</td>
                    <td class="check">Multiple</td>
                </tr>
              
            </tbody>
        </table>
    </div>
</div>

<!-- Examples -->
<div class="section" id="examples">
    <div class="section-header">
        <h2>Start building in minutes</h2>
        <p>Clean, readable code examples to get you started quickly</p>
    </div>

    <div class="code-example">
        <div class="code-header">
            <h3><i class="fas fa-volume-up"></i> Audio Stream Example</h3>
            <div class="code-actions">
                <button class="code-btn" id="copyAudio">
                    <i class="fas fa-copy"></i> Copy
                </button>
            </div>
        </div>
        <div class="code-content">
            <textarea id="audioCode">/* 
 * GLPS Audio Stream Example
 * 
 * This program demonstrates basic usage of the GLPS audio streaming library
 * to play an audio file for a fixed duration.
 */

/* Include the GLPS audio stream header file */
/* This provides the function declarations and types for audio streaming */
#include <GLPS/glps_audio_stream.h>

/* 
 * Main function - Program entry point
 * Returns: int - Program exit status (0 for success)
 */
int main()
{
    /*
     * Initialize the GLPS audio stream system
     * 
     * glps_audio_stream_init() creates and configures an audio stream context
     * Parameters:
     *   "default" - Audio device name (uses system default output device)
     *   4096      - Buffer size in samples (affects latency and stability)
     *   44100     - Sample rate in Hz (standard CD quality)
     *   2         - Number of channels (2 = stereo)
     *   16        - Bit depth (16 bits per sample)
     *   4096      - Number of buffers (affects streaming smoothness)
     * 
     * Returns: glps_audio_stream* - Pointer to audio stream context, or NULL on failure
     */
    glps_audio_stream *am = glps_audio_stream_init("default", 4096, 44100, 2, 16, 4096);
    
    /*
     * Play an audio file using the initialized audio stream
     * 
     * glps_audio_stream_play() starts playback of the specified audio file
     * Parameters:
     *   am        - Pointer to the initialized audio stream context
     *   "./test.mp3" - Path to the audio file to play
     *   44100     - Output sample rate (should match file's sample rate)
     *   2         - Output channels (should match file's channel count)
     *   16        - Output bit depth (should match file's bit depth)
     *   4096      - Buffer size for file streaming
     * 
     * Note: The function likely returns immediately, starting playback in background
     */
    glps_audio_stream_play(am, "./test.mp3", 44100, 2, 16, 4096);
    
    /*
     * Keep the program running while audio plays
     * 
     * sleep(5) pauses the main thread for 5 seconds
     * This allows the audio to play for 5 seconds before the program exits
     * Without this, the program would exit immediately, stopping playback
     */
    sleep(5);
    
    /*
     * Program cleanup and exit
     *
     */

    glps_audio_stream_destroy(am);
    return 0;  /* Return 0 indicating successful execution */
}</textarea>
        </div>
    </div>

    <div class="code-example">
        <div class="code-header">
            <h3><i class="fas fa-cube"></i> Vulkan Graphics Example</h3>
            <div class="code-actions">
                <button class="code-btn" id="copyVulkan">
                    <i class="fas fa-copy"></i> Copy
                </button>
            </div>
        </div>
        <div class="code-content">
            <textarea id="vulkanCode">#define GLPS_USE_VULKAN
#include <GLPS/glps_window_manager.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define VK_CHECK(x)                                                                 \
    do                                                                              \
    {                                                                               \
        VkResult err = x;                                                           \
        if (err != VK_SUCCESS)                                                      \
        {                                                                           \
            fprintf(stderr, "Vulkan error %d at %s:%d\n", err, __FILE__, __LINE__); \
            exit(1);                                                                \
        }                                                                           \
    } while (0)

typedef struct
{
    float x, y, z;
    float r, g, b, a;
} Vertex;

typedef struct
{
    VkBuffer buffer;
    VkDeviceMemory memory;
    uint32_t vertex_count;
} PrimitiveBuffer;

static uint32_t *read_spirv_file(const char *filename, size_t *size)
{
    FILE *file = fopen(filename, "rb");
    if (!file)
    {
        fprintf(stderr, "Failed to open shader file: %s\n", filename);
        return NULL;
    }
    fseek(file, 0, SEEK_END);
    *size = ftell(file);
    fseek(file, 0, SEEK_SET);
    if (*size % 4 != 0)
    {
        fprintf(stderr, "SPIR-V size not multiple of 4: %s\n", filename);
        fclose(file);
        return NULL;
    }
    uint32_t *code = (uint32_t *)malloc(*size);
    if (!code)
    {
        fclose(file);
        return NULL;
    }
    if (fread(code, 1, *size, file) != *size)
    {
        fprintf(stderr, "Failed to read shader: %s\n", filename);
        free(code);
        fclose(file);
        return NULL;
    }
    fclose(file);
    return code;
}

VkShaderModule create_shader_module(VkDevice device, const uint32_t *code, size_t size)
{
    VkShaderModuleCreateInfo info = {
        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        .codeSize = size,
        .pCode = code};
    VkShaderModule module;
    VK_CHECK(vkCreateShaderModule(device, &info, NULL, &module));
    return module;
}

uint32_t find_memory_type(VkPhysicalDevice gpu, uint32_t type_filter, VkMemoryPropertyFlags props)
{
    VkPhysicalDeviceMemoryProperties mem_props;
    vkGetPhysicalDeviceMemoryProperties(gpu, &mem_props);
    for (uint32_t i = 0; i < mem_props.memoryTypeCount; i++)
    {
        if ((type_filter & (1 << i)) && (mem_props.memoryTypes[i].propertyFlags & props) == props)
            return i;
    }
    fprintf(stderr, "Failed to find suitable memory type!\n");
    exit(1);
}

PrimitiveBuffer create_rectangle(VkDevice device, VkPhysicalDevice gpu, float x, float y, float w, float h, float r, float g, float b, float a, int win_w, int win_h)
{
    float x1 = (x / (float)win_w) * 2.0f - 1.0f;
    float y1 = (y / (float)win_h) * 2.0f - 1.0f;
    float x2 = ((x + w) / (float)win_w) * 2.0f - 1.0f;
    float y2 = ((y + h) / (float)win_h) * 2.0f - 1.0f;

    Vertex vertices[6] = {
        {x1, y1, 0, r, g, b, a},
        {x2, y1, 0, r, g, b, a},
        {x2, y2, 0, r, g, b, a},
        {x1, y1, 0, r, g, b, a},
        {x2, y2, 0, r, g, b, a},
        {x1, y2, 0, r, g, b, a}};

    VkBufferCreateInfo buf_info = {
        .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        .size = sizeof(vertices),
        .usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
        .sharingMode = VK_SHARING_MODE_EXCLUSIVE};

    PrimitiveBuffer pb = {0};
    pb.vertex_count = 6;
    VK_CHECK(vkCreateBuffer(device, &buf_info, NULL, &pb.buffer));

    VkMemoryRequirements mem_req;
    vkGetBufferMemoryRequirements(device, pb.buffer, &mem_req);

    VkMemoryAllocateInfo alloc_info = {
        .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        .allocationSize = mem_req.size,
        .memoryTypeIndex = find_memory_type(gpu, mem_req.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)};

    VK_CHECK(vkAllocateMemory(device, &alloc_info, NULL, &pb.memory));
    VK_CHECK(vkBindBufferMemory(device, pb.buffer, pb.memory, 0));

    void *data;
    vkMapMemory(device, pb.memory, 0, sizeof(vertices), 0, &data);
    memcpy(data, vertices, sizeof(vertices));
    vkUnmapMemory(device, pb.memory);

    return pb;
}

void destroy_primitive_buffer(VkDevice device, PrimitiveBuffer *pb)
{
    if (pb->buffer)
        vkDestroyBuffer(device, pb->buffer, NULL);
    if (pb->memory)
        vkFreeMemory(device, pb->memory, NULL);
    memset(pb, 0, sizeof(PrimitiveBuffer));
}

void draw_primitive(VkCommandBuffer cmd, PrimitiveBuffer *pb)
{
    VkBuffer vb[] = {pb->buffer};
    VkDeviceSize offs[] = {0};
    vkCmdBindVertexBuffers(cmd, 0, 1, vb, offs);
    vkCmdDraw(cmd, pb->vertex_count, 1, 0, 0);
}

int main()
{
    size_t vert_size, frag_size;
    uint32_t *vert_spv = read_spirv_file("./vert.spv", &vert_size);
    uint32_t *frag_spv = read_spirv_file("./frag.spv", &frag_size);
    if (!vert_spv || !frag_spv)
    {
        fprintf(stderr, "Failed shaders\n");
        return 1;
    }

    glps_WindowManager *wm = glps_wm_init();
    size_t window = glps_wm_window_create(wm, "Vulkan Primitives", 800, 600);

    // Vulkan instance
    VkApplicationInfo app_info = {.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO, .pApplicationName = "Primitives", .apiVersion = VK_API_VERSION_1_0};
    glps_VulkanExtensionArray exts_arr = glps_wm_vk_get_extensions_arr();
    VkInstanceCreateInfo inst_info = {
        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        .pApplicationInfo = &app_info,
        .enabledExtensionCount = exts_arr.count,
        .ppEnabledExtensionNames = exts_arr.names};
    VkInstance instance;
    VK_CHECK(vkCreateInstance(&inst_info, NULL, &instance));

    VkSurfaceKHR surface;
    glps_wm_vk_create_surface(wm, window, &instance, &surface);
    printf("Vulkan Xlib surface created!\n");

    // Pick GPU
    uint32_t gpu_count = 0;
    vkEnumeratePhysicalDevices(instance, &gpu_count, NULL);
    if (gpu_count == 0)
    {
        fprintf(stderr, "No GPU found!\n");
        return 1;
    }
    VkPhysicalDevice devices[8];
    vkEnumeratePhysicalDevices(instance, &gpu_count, devices);
    VkPhysicalDevice gpu = devices[0];

    // Queue
    uint32_t qcount = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(gpu, &qcount, NULL);
    VkQueueFamilyProperties qprops[32];
    vkGetPhysicalDeviceQueueFamilyProperties(gpu, &qcount, qprops);
    int qidx = -1;
    for (uint32_t i = 0; i < qcount; i++)
    {
        VkBool32 pres = 0;
        vkGetPhysicalDeviceSurfaceSupportKHR(gpu, i, surface, &pres);
        if ((qprops[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) && pres)
        {
            qidx = i;
            break;
        }
    }
    if (qidx == -1)
    {
        fprintf(stderr, "No queue found!\n");
        return 1;
    }

    float priority = 1.0f;
    VkDeviceQueueCreateInfo qinfo = {.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, .queueFamilyIndex = qidx, .queueCount = 1, .pQueuePriorities = &priority};
    const char *dev_exts[] = {VK_KHR_SWAPCHAIN_EXTENSION_NAME};
    VkDeviceCreateInfo dinfo = {.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, .queueCreateInfoCount = 1, .pQueueCreateInfos = &qinfo, .enabledExtensionCount = 1, .ppEnabledExtensionNames = dev_exts};
    VkDevice device;
    VK_CHECK(vkCreateDevice(gpu, &dinfo, NULL, &device));
    VkQueue queue;
    vkGetDeviceQueue(device, qidx, 0, &queue);

    // Swapchain
    VkSurfaceCapabilitiesKHR caps;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(gpu, surface, &caps);
    VkExtent2D extent = caps.currentExtent.width == UINT32_MAX ? (VkExtent2D){800, 600} : caps.currentExtent;
    uint32_t img_count = caps.minImageCount + 1;
    if (caps.maxImageCount > 0 && img_count > caps.maxImageCount)
        img_count = caps.maxImageCount;

    uint32_t fmt_count;
    vkGetPhysicalDeviceSurfaceFormatsKHR(gpu, surface, &fmt_count, NULL);
    VkSurfaceFormatKHR formats[32];
    vkGetPhysicalDeviceSurfaceFormatsKHR(gpu, surface, &fmt_count, formats);
    VkSurfaceFormatKHR fmt = formats[0];

    VkSwapchainCreateInfoKHR swap_info = {
        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
        .surface = surface,
        .minImageCount = img_count,
        .imageFormat = fmt.format,
        .imageColorSpace = fmt.colorSpace,
        .imageExtent = extent,
        .imageArrayLayers = 1,
        .imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
        .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,
        .preTransform = caps.currentTransform,
        .compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
        .presentMode = VK_PRESENT_MODE_FIFO_KHR,
        .clipped = VK_TRUE};
    VkSwapchainKHR swapchain;
    VK_CHECK(vkCreateSwapchainKHR(device, &swap_info, NULL, &swapchain));

    uint32_t real_count = 0;
    vkGetSwapchainImagesKHR(device, swapchain, &real_count, NULL);
    VkImage imgs[8];
    vkGetSwapchainImagesKHR(device, swapchain, &real_count, imgs);

    VkImageView views[8];
    for (uint32_t i = 0; i < real_count; i++)
    {
        VkImageViewCreateInfo iv = {.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, .image = imgs[i], .viewType = VK_IMAGE_VIEW_TYPE_2D, .format = fmt.format, .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1}};
        VK_CHECK(vkCreateImageView(device, &iv, NULL, &views[i]));
    }

    // Render pass
    VkAttachmentDescription color_attachment = {.format = fmt.format, .samples = VK_SAMPLE_COUNT_1_BIT, .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR, .storeOp = VK_ATTACHMENT_STORE_OP_STORE, .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE, .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED, .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR};
    VkAttachmentReference color_ref = {.attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL};
    VkSubpassDescription subpass = {.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS, .colorAttachmentCount = 1, .pColorAttachments = &color_ref};
    VkRenderPassCreateInfo rp_info = {.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, .attachmentCount = 1, .pAttachments = &color_attachment, .subpassCount = 1, .pSubpasses = &subpass};
    VkRenderPass render_pass;
    VK_CHECK(vkCreateRenderPass(device, &rp_info, NULL, &render_pass));

    // Framebuffers
    VkFramebuffer framebuffers[8];
    for (uint32_t i = 0; i < real_count; i++)
    {
        VkFramebufferCreateInfo fb = {.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, .renderPass = render_pass, .attachmentCount = 1, .pAttachments = &views[i], .width = extent.width, .height = extent.height, .layers = 1};
        VK_CHECK(vkCreateFramebuffer(device, &fb, NULL, &framebuffers[i]));
    }

    // Shaders
    VkShaderModule vert_module = create_shader_module(device, vert_spv, vert_size);
    VkShaderModule frag_module = create_shader_module(device, frag_spv, frag_size);
    free(vert_spv);
    free(frag_spv);

    VkPipelineShaderStageCreateInfo stages[2] = {
        {.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_VERTEX_BIT, .module = vert_module, .pName = "main"},
        {.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_FRAGMENT_BIT, .module = frag_module, .pName = "main"}};

    VkVertexInputBindingDescription binding = {.binding = 0, .stride = sizeof(Vertex), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX};
    VkVertexInputAttributeDescription attrs[2] = {{.location = 0, .binding = 0, .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(Vertex, x)}, {.location = 1, .binding = 0, .format = VK_FORMAT_R32G32B32A32_SFLOAT, .offset = offsetof(Vertex, r)}};
    VkPipelineVertexInputStateCreateInfo vi_info = {.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, .vertexBindingDescriptionCount = 1, .pVertexBindingDescriptions = &binding, .vertexAttributeDescriptionCount = 2, .pVertexAttributeDescriptions = attrs};
    VkPipelineInputAssemblyStateCreateInfo ia = {.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, .primitiveRestartEnable = VK_FALSE};

    VkViewport vp = {.x = 0, .y = 0, .width = (float)extent.width, .height = (float)extent.height, .minDepth = 0, .maxDepth = 1};
    VkRect2D scissor = {{0, 0}, extent};
    VkPipelineViewportStateCreateInfo vp_info = {.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, .viewportCount = 1, .pViewports = &vp, .scissorCount = 1, .pScissors = &scissor};

    VkPipelineRasterizationStateCreateInfo raster = {.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, .depthClampEnable = VK_FALSE, .rasterizerDiscardEnable = VK_FALSE, .polygonMode = VK_POLYGON_MODE_FILL, .cullMode = VK_CULL_MODE_NONE, .frontFace = VK_FRONT_FACE_CLOCKWISE, .depthBiasEnable = VK_FALSE, .lineWidth = 1.0f};
    VkPipelineMultisampleStateCreateInfo ms = {.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT, .sampleShadingEnable = VK_FALSE};
    VkPipelineColorBlendAttachmentState cb_attach = {.blendEnable = VK_TRUE, .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA, .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA, .colorBlendOp = VK_BLEND_OP_ADD, .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE, .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO, .alphaBlendOp = VK_BLEND_OP_ADD, .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT};
    VkPipelineColorBlendStateCreateInfo cb = {.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, .logicOpEnable = VK_FALSE, .attachmentCount = 1, .pAttachments = &cb_attach};

    VkPipelineLayout pl;
    VkPipelineLayoutCreateInfo pl_info = {.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO};
    VK_CHECK(vkCreatePipelineLayout(device, &pl_info, NULL, &pl));
    VkGraphicsPipelineCreateInfo pipe_info = {.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, .stageCount = 2, .pStages = stages, .pVertexInputState = &vi_info, .pInputAssemblyState = &ia, .pViewportState = &vp_info, .pRasterizationState = &raster, .pMultisampleState = &ms, .pDepthStencilState = NULL, .pColorBlendState = &cb, .pDynamicState = NULL, .layout = pl, .renderPass = render_pass, .subpass = 0, .basePipelineHandle = VK_NULL_HANDLE, .basePipelineIndex = -1};
    VkPipeline pipeline;
    VK_CHECK(vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipe_info, NULL, &pipeline));

    // Primitives
    PrimitiveBuffer red = create_rectangle(device, gpu, 100, 100, 200, 150, 1, 0, 0, 1, extent.width, extent.height);
    PrimitiveBuffer green = create_rectangle(device, gpu, 400, 200, 150, 100, 0, 1, 0, 1, extent.width, extent.height);
    PrimitiveBuffer blue = create_rectangle(device, gpu, 250, 350, 300, 120, 0, 0, 1, 1, extent.width, extent.height);

    // Command pool + buffers
    VkCommandPoolCreateInfo pool_info = {.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, .queueFamilyIndex = qidx};
    VkCommandPool pool;
    VK_CHECK(vkCreateCommandPool(device, &pool_info, NULL, &pool));
    VkCommandBufferAllocateInfo alloc_info = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, .commandPool = pool, .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY, .commandBufferCount = real_count};
    VkCommandBuffer *cmds = malloc(sizeof(VkCommandBuffer) * real_count);
    VK_CHECK(vkAllocateCommandBuffers(device, &alloc_info, cmds));

    VkSemaphoreCreateInfo sem_info = {.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO};
    VkSemaphore img_avail, render_done;
    VK_CHECK(vkCreateSemaphore(device, &sem_info, NULL, &img_avail));
    VK_CHECK(vkCreateSemaphore(device, &sem_info, NULL, &render_done));

    // Main loop
    while (!glps_wm_should_close(wm))
    {
        uint32_t img_idx;
        VK_CHECK(vkAcquireNextImageKHR(device, swapchain, UINT64_MAX, img_avail, VK_NULL_HANDLE, &img_idx));

        VkCommandBufferBeginInfo begin = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
        VK_CHECK(vkBeginCommandBuffer(cmds[img_idx], &begin));
        VkClearValue clear = {.color = {0.1f, 0.1f, 0.1f, 1.0f}};
        VkRenderPassBeginInfo rpbi = {.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, .renderPass = render_pass, .framebuffer = framebuffers[img_idx], .renderArea = {{0, 0}, extent}, .clearValueCount = 1, .pClearValues = &clear};
        vkCmdBeginRenderPass(cmds[img_idx], &rpbi, VK_SUBPASS_CONTENTS_INLINE);
        vkCmdBindPipeline(cmds[img_idx], VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);
        draw_primitive(cmds[img_idx], &red);
        draw_primitive(cmds[img_idx], &green);
        draw_primitive(cmds[img_idx], &blue);
        vkCmdEndRenderPass(cmds[img_idx]);
        VK_CHECK(vkEndCommandBuffer(cmds[img_idx]));

        VkSubmitInfo submit = {.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO, .waitSemaphoreCount = 1, .pWaitSemaphores = &img_avail, .pWaitDstStageMask = (VkPipelineStageFlags[]){VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT}, .commandBufferCount = 1, .pCommandBuffers = &cmds[img_idx], .signalSemaphoreCount = 1, .pSignalSemaphores = &render_done};
        VK_CHECK(vkQueueSubmit(queue, 1, &submit, VK_NULL_HANDLE));

        VkPresentInfoKHR pres = {.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, .waitSemaphoreCount = 1, .pWaitSemaphores = &render_done, .swapchainCount = 1, .pSwapchains = &swapchain, .pImageIndices = &img_idx};
        VK_CHECK(vkQueuePresentKHR(queue, &pres));
        vkQueueWaitIdle(queue);
    }

    vkDeviceWaitIdle(device);

    destroy_primitive_buffer(device, &red);
    destroy_primitive_buffer(device, &green);
    destroy_primitive_buffer(device, &blue);
    vkDestroyPipeline(device, pipeline, NULL);
    vkDestroyPipelineLayout(device, pl, NULL);
    vkDestroyShaderModule(device, vert_module, NULL);
    vkDestroyShaderModule(device, frag_module, NULL);
    for (uint32_t i = 0; i < real_count; i++)
        vkDestroyFramebuffer(device, framebuffers[i], NULL);
    for (uint32_t i = 0; i < real_count; i++)
        vkDestroyImageView(device, views[i], NULL);
    vkDestroySwapchainKHR(device, swapchain, NULL);
    vkDestroyRenderPass(device, render_pass, NULL);
    vkDestroySemaphore(device, img_avail, NULL);
    vkDestroySemaphore(device, render_done, NULL);
    vkDestroyCommandPool(device, pool, NULL);
    vkDestroyDevice(device, NULL);
    vkDestroySurfaceKHR(instance, surface, NULL);
    vkDestroyInstance(instance, NULL);
    glps_wm_destroy(wm);
    free(cmds);

    return 0;
}
</textarea>
        </div>
    </div>
</div>

    <div class="footer-bottom">
        <p>&copy; 2025 GLPS Project. Released under the MIT License.</p>
    </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
<script>
    // Mobile navigation toggle
    document.getElementById('mobileToggle').addEventListener('click', function() {
        document.getElementById('globalnav').classList.toggle('active');
    });

    // Header scroll effect
    window.addEventListener('scroll', function() {
        const header = document.getElementById('globalheader');
        if (window.scrollY > 50) {
            header.classList.add('scrolled');
        } else {
            header.classList.remove('scrolled');
        }
    });

    // Initialize CodeMirror editors with material theme
    const audioEditor = CodeMirror.fromTextArea(document.getElementById('audioCode'), {
        mode: 'text/x-csrc',
        theme: 'material',
        lineNumbers: true,
        readOnly: true,
        matchBrackets: true,
        autoCloseBrackets: true,
        lineWrapping: true
    });

    const vulkanEditor = CodeMirror.fromTextArea(document.getElementById('vulkanCode'), {
        mode: 'text/x-csrc',
        theme: 'material',
        lineNumbers: true,
        readOnly: true,
        matchBrackets: true,
        autoCloseBrackets: true,
        lineWrapping: true
    });

    // Copy code functionality
    document.getElementById('copyAudio').addEventListener('click', function() {
        copyCode(audioEditor, this);
    });

    document.getElementById('copyVulkan').addEventListener('click', function() {
        copyCode(vulkanEditor, this);
    });

    function copyCode(editor, button) {
        const code = editor.getValue();
        navigator.clipboard.writeText(code).then(() => {
            const originalText = button.innerHTML;
            button.innerHTML = '<i class="fas fa-check"></i> Copied!';
            setTimeout(() => {
                button.innerHTML = originalText;
            }, 2000);
        });
    }

    // Smooth scrolling for anchor links
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute('href'));
            if (target) {
                target.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
                
                // Update active nav link
                document.querySelectorAll('#globalnav a').forEach(link => {
                    link.classList.remove('active');
                });
                this.classList.add('active');
            }
        });
    });
</script>

</body>
</html>